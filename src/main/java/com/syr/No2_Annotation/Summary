-No2_annotation——
                 |——Test01:测试注解+自定义注解
                 |——Test02:1.反射测试，2.获取Class类的方法
                 |——Test03:获取所有类型的Class
                 |——Test04：测试类的主动引用和被动引用
                 |——Test05：引导类加载器(java平台核心库rt.jar包)，扩展类加载器(jre/lib/ext目录下)，系统类加载器
                 |——Test06:获得类的属性
                 |——Test07：动态创建对象,利用反射
                 |——Test08:反射操作注解。ORM：对象关系映射


A.注解：Annotation,不是程序本身，可以对程序作出解释，可以被其他程序读取
          1.内置注解：
          @Override:重写注解,java.lang.Override
          @Deprecated:表示程序不鼓励程序员使用这样的元素
          @SuppressWarnings:抑制警告
          2.元注解：
          @Target():描述注解的使用范围
          @Retention():在什么级别保存该注解有效 SOURCE<CLASS<RUNTIME
          @Inherited:子类可以继承父类的该注解

B.反射：
1.动态语言：运行时可以改变其结构的语言，javascript,Object-C,PHP,Python,C#
2.静态语言：java，C，C++。java不是动态语言，但是java可以称之为准静态语言。利用反射机制获得类似动态语言的特性。
          正常方式：引入需要包类的名称->new实例化->取得实例化对象
          反射方式：实例化对象->getClass()->获得完整的包类的名称

C.类的加载过程：
    1.类的加载:将类的Class文件读入内存；
              并为之创建一个java.lang.Class对象
    2.类的链接：将类的二进制数据合并到JRE中；
              为类变量（static）分配内存并设置类变量默认初始阶段，初始化为0。
    3.类的初始化：JVM负责对类进行初始化；
              执行类构造器的<clinit>()方法，自动加载和合并代码中的语句

D.类加载器的作用：
    源程序(*.java文件)->Java编译器->字节码(.class文件)->类加载器->字节码校验器->解释器->操作系统平台

E：分析性能问题：
    1.普通方式调用方法：快捷，9ms
    2.反射调用方法：耗时，5.7s
    3.反射调用方法，关闭检测：稍好，1.9s
