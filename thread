位置：StudyJAVA\src\main\java\com\syr\No1_thread\
No1_thread——
            线程的五大状态：
            Thread.state
            NEW创建状态，就绪状态，RUNNABLE运行状态，(BLOCKED,WAITING,TIME_WAITING)阻塞状态，TERMINATED死亡状态
            1.创建线程（启动线程）就绪状态（获取CPU调度）运行状态（释放CPU调度）就绪状态
            2.运行状态（用户输入线程停止，线程自然停止外部干预）死亡状态
            3.运行状态（线程阻塞）阻塞状态（阻塞解除）就绪状态
            |——thread1——线程创建
                        |——TestThread1：创建线程方式一，继承Thread
                        |——TestThread1_test1:利用多线程下载图片
                        |——TestThread2：创建线程方式二，实现Runnable接口
                        |——TestThread2——test1：龟兔赛跑问题
                        |——TestThread2——test2：抢票问题（线程不安全）
                        |——TestThread3：创建线程方式三：实现Callable接口(线程池)
            |——thread2——线程基础
                        |——Lambda:lambda表达式的简化的过程详解(外部类-静态内部类-局部内部类-匿名内部类-Lambda表达式)
                        |——Lambda2：带有参数的Lambda表达式简化的过程
                        |——StaticProxy：静态代理（举例说明代理模式：Company代理You，Thread代理Runnable接口）
            |——thread3——线程方法
                        |——DaemonThread：线程分为守护线程+用户线程，后台记录操作，监控内存，垃圾回收等守护线程。
                                         GC守护线程，虚拟机确保用户线程执行完毕，不用等待守护线程执行完毕
                        |——JoinThread：Join合并线程，待此线程完成后，在执行其他线程，其他线程阻塞
                        |——SleepThread:睡眠让线程从阻塞状态转为就绪状态。实例：1.模拟网络延迟 2.模拟倒计时  3.模拟打印当前时间
                                       每个对象都有一把锁，但是sleep不会释放锁
                        |——StopThread：停止线程，推荐手动停止，设置标志位flag（设置修改标志位的方法stop）
                        |——ThreadPriority：优先级高的线程不一定先执行，要看CPU的心情
                        |——ThreadState:测试线程的状态，线程五大状态：NEW,RUNNABLE,TERMINATED,TERMINATED(注意：测试时记得加slepp延迟，否则运行太快观察不到变化)
                                       线程终止或者结束，一旦进入死亡线程后，就不能再次启动
                        |——YieldThread：礼让将线程从运行状态转为就绪状态。
                                        礼让线程，让当前正在执行的线程暂停，但不阻塞，yield礼让不一定成功，看CPU心情
            |——thread4——线程同步：多个资源操作同一资源；并发：同一个对象被多个线程同时操作（多个线程，同时买票，同时取钱）
                        解决线程同步的方法：队列+锁，加入锁机制synchronized
                        每个对象都有一把锁，但是sleep不会释放锁，wait会释放锁。
                        带来的问题：1.一个线程持有锁会导致其他需要该锁的线程挂起
                                  2.在多个线程竞争下加锁释放锁会引起过多的上下文切换以及性能问题
                                  3.如果一个优先级低的线程等待优先级高的线程，会导致线程的优先级倒置，引起性能问题。
                        三大不全的案例：1.不安全的买票+2.不安全的取钱+3.不安全的集合ArrayList（注：每个线程都在自己的工作内存交互，内存控制不当会导致数据不一致）
                        |——UnsafeBuyTicket:不安全的买票
                        |——UnsafeList:不安全的集合ArrayList
                        |——UnsafeBank:不安全的取钱
                        线程的同步方法：加入synchronized关键字(synchronized块和synchronized方法)，必须获得对象的锁，否则线程会阻塞。
                                原理：方法一旦执行就独占该锁，直到方法执行结束，释放锁，后面被阻塞的线程才会获得该锁，继续执行。
                                缺点：若将一个大的方法声明为synchronized将会影响效率（只有修改的代码需要同步，只读代码大家看到的都一样，锁的太多会浪费资源）
                        同步块：synchronized(obj){}：obj是同步监视器：
                              obj可以是任何对象但是推荐使用共享资源作为同步监视器
                              同步方法中无需指定同步监视器，因为同步方法中的同步监视器就是this，就是对象本身或者说是class。
                              同步监视器的执行过程：1.线程一访问，锁定同步监视器，执行其中的代码
                                                2.线程二访问，发现同步监视器被占用，无法访问
                                                3.线程一执行完毕解锁同步监视器
                                                4.线程二访问，发现同步监视器没有锁，锁定然后访问
                        在以上三个不安全的案例中分别加上synchroized即可解除不安全的状态；注意：锁的对象是变化的量，需要增删改的对象
                        |——JUCThread:CopyOnWriteArrayList<String>是安全类型的集合，在import java.util.concurrent包下
                        |——DeadLock：死锁
                        |——Lock:显示的定义同步锁，ReentrantLock（可重入锁）实现了Lock，它拥有和synchronized相同的并发性和内存语义：可以显示加锁，释放锁
                           Lock和synchronized区别：1.Lock是显示的锁，手动加锁和释放锁(别忘记关锁)，synchronized是隐士的锁，除了区域自动释放锁
                                                  2.Lock只有代码块，synchronized既有代码块锁也有方法锁
                                                  3.使用Lock锁，JVM会花费较少的时间来调用线程，性能更好
                                                  4.使用顺序：Lock>同步代码块（方法体内）>同步方法（方法体外）
            ——thread5——综合类(生产者消费者问题)
                       Object类：
                               wait方法：线程一直等待，直到其他线程通知，会释放锁。
                               wait(long timeout)：指定等待的毫秒数
                               notify方法：唤醒一个处于等待的线程
                               notifyAll()：唤醒同一个对象上所有调用wait方法的线程，优先级别高的线程优先调度
                       |——TestPC：解决方式1，管程法(利用缓存区解决):生产者，消费者，产品，缓冲区
                       |——TestPC：解决方式2，信号灯法
                       |——TestPool:线程池,避免重复创建销毁，重复利用。1.创建服务，创建线程池。2.丢入线程，service.execute执行。3.关闭链接
